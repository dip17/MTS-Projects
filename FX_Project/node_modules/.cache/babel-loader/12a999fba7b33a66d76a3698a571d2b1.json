{"ast":null,"code":"\"use strict\";\n\nfunction _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n  return _typeof(obj);\n}\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.FocusError = FocusError;\nvar _react = _interopRequireWildcard(require(\"react\"));\nvar _formik = require(\"formik\");\nvar _flattenToLodashFormat = _interopRequireDefault(require(\"./flattenToLodashFormat\"));\nfunction _interopRequireDefault(obj) {\n  return obj && obj.__esModule ? obj : {\n    \"default\": obj\n  };\n}\nfunction _getRequireWildcardCache() {\n  if (typeof WeakMap !== \"function\") return null;\n  var cache = new WeakMap();\n  _getRequireWildcardCache = function _getRequireWildcardCache() {\n    return cache;\n  };\n  return cache;\n}\nfunction _interopRequireWildcard(obj) {\n  if (obj && obj.__esModule) {\n    return obj;\n  }\n  if (obj === null || _typeof(obj) !== \"object\" && typeof obj !== \"function\") {\n    return {\n      \"default\": obj\n    };\n  }\n  var cache = _getRequireWildcardCache();\n  if (cache && cache.has(obj)) {\n    return cache.get(obj);\n  }\n  var newObj = {};\n  var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;\n  for (var key in obj) {\n    if (Object.prototype.hasOwnProperty.call(obj, key)) {\n      var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;\n      if (desc && (desc.get || desc.set)) {\n        Object.defineProperty(newObj, key, desc);\n      } else {\n        newObj[key] = obj[key];\n      }\n    }\n  }\n  newObj[\"default\"] = obj;\n  if (cache) {\n    cache.set(obj, newObj);\n  }\n  return newObj;\n}\nfunction FocusError(_ref) {\n  var _ref$formik = _ref.formik,\n    isSubmitting = _ref$formik.isSubmitting,\n    touched = _ref$formik.touched,\n    isValidating = _ref$formik.isValidating,\n    errors = _ref$formik.errors,\n    _ref$focusDelay = _ref.focusDelay,\n    focusDelay = _ref$focusDelay === void 0 ? 100 : _ref$focusDelay;\n  (0, _react.useEffect)(function () {\n    if (isSubmitting && !isValidating) {\n      // Flatten touched as a way to check nested keys easily and\n      // fix the depth problem when the error text is created\n      // by a React component like react-intl.\n      var flattedTouched = (0, _flattenToLodashFormat[\"default\"])(touched);\n      var errorNames = Object.keys(flattedTouched).reduce(function (prev, key) {\n        if ((0, _formik.getIn)(errors, key)) {\n          prev.push(key);\n        }\n        return prev;\n      }, []);\n      if (errorNames.length && typeof document !== \"undefined\") {\n        var errorElement;\n        errorNames.forEach(function (errorKey) {\n          var selector = \"[name=\\\"\".concat(errorKey, \"\\\"]\");\n          if (!errorElement) {\n            errorElement = document.querySelector(selector);\n            return;\n          }\n        }); // This is to avoid the other components autofocus when submitting\n\n        setTimeout(function () {\n          errorElement && errorElement.focus();\n        }, focusDelay);\n      }\n    }\n  }, [isSubmitting, isValidating, errors, touched, focusDelay]);\n  return /*#__PURE__*/_react[\"default\"].createElement(_react.Fragment, null);\n}","map":{"version":3,"sources":["../src/FocusError.tsx"],"names":["FocusError","formik","isSubmitting","touched","isValidating","errors","focusDelay","flattedTouched","errorNames","keys","reduce","prev","key","push","length","document","errorElement","forEach","errorKey","selector","querySelector","setTimeout","focus"],"mappings":";;;;;;;;;;;;;;;;;;;;AAAA,IAAA,MAAA,GAAA,uBAAA,CAAA,OAAA,CAAA,OAAA,CAAA,CAAA;AACA,IAAA,OAAA,GAAA,OAAA,CAAA,QAAA,CAAA;AACA,IAAA,sBAAA,GAAA,sBAAA,CAAA,OAAA,CAAA,yBAAA,CAAA,CAAA;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAsBO,SAASA,UAAT,CAAA,IAAA,EAGa;EAAA,IAAA,WAAA,GAAA,IAAA,CAFlBC,MAEkB;IAFRC,YAEQ,GAAA,WAAA,CAFRA,YAEQ;IAFMC,OAEN,GAAA,WAAA,CAFMA,OAEN;IAFeC,YAEf,GAAA,WAAA,CAFeA,YAEf;IAF6BC,MAE7B,GAAA,WAAA,CAF6BA,MAE7B;IAAA,eAAA,GAAA,IAAA,CADlBC,UACkB;IADlBA,UACkB,GAAA,eAAA,KAAA,KAAA,CAAA,GADL,GACK,GAAA,eAAA;EAClB,CAAA,CAAA,EAAA,MAAA,CAAA,SAAA,EAAU,YAAM;IACd,IAAIJ,YAAY,IAAI,CAACE,YAArB,EAAmC;MACjC;MACA;MACA;MACA,IAAMG,cAAc,GAAG,CAAA,CAAA,EAAA,sBAAA,CAAA,SAAA,CAAA,EAAsBJ,OAAtB,CAAvB;MAEA,IAAMK,UAAU,GAAG,MAAM,CAACC,IAAP,CAAYF,cAAZ,CAAA,CAA4BG,MAA5B,CAAmC,UAACC,IAAD,EAAOC,GAAP,EAAe;QACnE,IAAI,CAAA,CAAA,EAAA,OAAA,CAAA,KAAA,EAAMP,MAAN,EAAcO,GAAd,CAAJ,EAAwB;UACtBD,IAAI,CAACE,IAALF,CAAUC,GAAVD,CAAAA;QACD;QACD,OAAOA,IAAP;MACD,CALkB,EAKhB,EALgB,CAAnB;MAOA,IAAIH,UAAU,CAACM,MAAXN,IAAqB,OAAOO,QAAP,KAAoB,WAA7C,EAA0D;QACxD,IAAIC,YAAJ;QAEAR,UAAU,CAACS,OAAXT,CAAmB,UAACU,QAAD,EAAc;UAC/B,IAAMC,QAAQ,GAAA,UAAA,CAAA,MAAA,CAAaD,QAAb,EAAA,KAAA,CAAd;UACA,IAAI,CAACF,YAAL,EAAmB;YACjBA,YAAY,GAAGD,QAAQ,CAACK,aAATL,CAAuBI,QAAvBJ,CAAfC;YACA;UACD;QACF,CANDR,CAAAA,CAHwD,CAWxD;;QACAa,UAAU,CAAC,YAAM;UACfL,YAAY,IAAIA,YAAY,CAACM,KAAbN,CAAAA,CAAhBA;QACD,CAFS,EAEPV,UAFO,CAAVe;MAGD;IACF;EACF,CA/BD,EA+BG,CAACnB,YAAD,EAAeE,YAAf,EAA6BC,MAA7B,EAAqCF,OAArC,EAA8CG,UAA9C,CA/BH,CAAA;EAiCA,OAAA,aAAO,MAAA,CAAA,SAAA,CAAA,CAAA,aAAA,CAAC,MAAA,CAAA,QAAD,EAAA,IAAA,CAAP;AACD","sourcesContent":["import React, { Fragment, useEffect } from \"react\";\nimport { getIn, FormikContextType, FormikValues } from \"formik\";\nimport flattenToLodashFormat from \"./flattenToLodashFormat\";\n\n/**\n * This component focus the first error in the Formik form after the validation.\n * Note: The first is not necessary the first on the screen, it's just the first\n * key in the touched object, order is not guaranteed.\n * */\n\nexport interface FocusErrorProps {\n  /**\n   * Values from Formik provider.\n   */\n  formik: Pick<\n  FormikContextType<FormikValues>,\n    \"isSubmitting\" | \"touched\" | \"isValidating\" | \"errors\"\n  >;\n  /**\n   * Time in ms to execute the focus in the component with the error, by default 100ms.\n   */\n  focusDelay?: number;\n}\n\nexport function FocusError({\n  formik: { isSubmitting, touched, isValidating, errors },\n  focusDelay = 100,\n}: FocusErrorProps) {\n  useEffect(() => {\n    if (isSubmitting && !isValidating) {\n      // Flatten touched as a way to check nested keys easily and\n      // fix the depth problem when the error text is created\n      // by a React component like react-intl.\n      const flattedTouched = flattenToLodashFormat(touched);\n\n      const errorNames = Object.keys(flattedTouched).reduce((prev, key) => {\n        if (getIn(errors, key)) {\n          prev.push(key);\n        }\n        return prev;\n      }, [] as string[]);\n\n      if (errorNames.length && typeof document !== \"undefined\") {\n        let errorElement: HTMLElement | null;\n\n        errorNames.forEach((errorKey) => {\n          const selector = `[name=\"${errorKey}\"]`;\n          if (!errorElement) {\n            errorElement = document.querySelector(selector);\n            return;\n          }\n        });\n\n        // This is to avoid the other components autofocus when submitting\n        setTimeout(() => {\n          errorElement && errorElement.focus();\n        }, focusDelay);\n      }\n    }\n  }, [isSubmitting, isValidating, errors, touched, focusDelay]);\n\n  return <Fragment />;\n}\n"]},"metadata":{},"sourceType":"script"}